# 逻辑连接符 `or` 

```follow
term prop or(prop p0, prop p1) { (p0 ∨ p1) }
axiom or.def(prop p0, prop p1) {
  |- imp(or(p0, p1), imp(not(p0), p1))
  |- imp(imp(not(p0), p1), or(p0, p1))
}
```

## 性质

```follow
thm or.left(prop p0, prop p1) {
  |- imp(p0, or(p0, p1))
} = {
  syl(p0, or(p0,p1), imp(not(p0),p1))
  or.def(p0, p1)
  con1d(p0, p0, p1)
  a1(p0, not(p1))
}
```

```follow
thm or.lefti(prop p0, prop p1) {
  |- or(p0, p1)
  -| p0
} = {
  mp(or(p0,p1), p0)
  or.left(p0, p1)
}
```

```follow
thm or.leftd(prop p0, prop p1, prop p2) {
  |- imp(p0, or(p1, p2))
  -| imp(p0, p1)
} = {
  syl(p0, or(p1,p2), p1)
  or.left(p1, p2)
}
```

```follow
thm or.right(prop p0, prop p1) {
  |- imp(p1, or(p0, p1))
} = {
  syl(p1, or(p0,p1), imp(not(p0),p1))
  or.def(p0, p1)
  a1(p1, not(p0))
}
```

```follow
thm or.righti(prop p0, prop p1) {
  |- or(p0, p1)
  -| p1
} = {
  mp(or(p0,p1), p1)
  or.right(p0, p1)
}
```

```follow
thm or.rightd(prop p0, prop p1, prop p2) {
  |- imp(p0, or(p1, p2))
  -| imp(p0, p2)
} = {
  syl(p0, or(p1,p2), p2)
  or.right(p1, p2)
}
```

## 交换率

```follow
thm or.com(prop p0, prop p1) {
  |- imp(or(p0, p1), or(p1, p0))
} = {
  syl(or(p0,p1), or(p1,p0), imp(not(p0),p1))
  or.def(p0, p1)
  syl(imp(not(p0),p1), or(p1,p0), imp(not(p1),p0))
  or.def(p1, p0)
  con1(p0, p1)
}
```

```follow
thm or.comi(prop p0, prop p1) {
  |- or(p0, p1)
  -| or(p1, p0)
} = {
  mp(or(p0,p1), or(p1,p0))
  or.com(p1, p0)
}
```

```follow
thm or.comd(prop p0, prop p1, prop p2) {
  |- imp(p0, or(p1, p2))
  -| imp(p0, or(p2, p1))
} = {
  syl(p0, or(p1,p2), or(p2,p1))
  or.com(p2, p1)
}
```

## 分类讨论 `or.cases`

```follow
thm or.cases(prop p0, prop p1, prop p2) {
  |- imp(imp(p0, p2), imp(imp(p1, p2), imp(or(p0, p1), p2)))
} = {
  rw3(imp(p0,p2), imp(p1,p2), imp(or(p0,p1),p2), ?prop3)
  mp(imp(?prop3,imp(or(p0,p1),p2)), imp(or(p0,p1),imp(not(p0),p1)))
  or.def(p0, p1)
  trans
}
```
