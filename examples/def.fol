type prop 
term prop imp(prop p1, prop p2) {(p1 → p2)}
term prop not(prop p1) {¬ p1}
term prop or(prop p1, prop p2) {(p1 ∨ p2)}
term prop and(prop p1, prop p2) {(p1 ∧ p2)}
term prop iff(prop p1, prop p2) {(p1 ↔ p2)}
term prop true { T }
term prop false { F }

axiom ax.1(prop p1, prop p2) {
  |- imp(p1, imp(p2, p1))
}
axiom ax.2(prop p1, prop p2, prop p3) {
  |- imp(imp(p1, imp(p2, p3)), imp(imp(p1, p2), imp(p1, p3)))
}
axiom ax.3(prop p1, prop p2) {
  |- imp(imp(not(p1), not(p2)), imp(p2, p1))
}
axiom ax.mp(prop p1, prop p2) {
  |- p1
  -| p2
  -| imp(p2, p1)
}
axiom and.def.1(prop p1, prop p2) {
  |- imp(and(p1, p2), not(imp(p1, not(p2))))
}
axiom and.def.2(prop p1, prop p2) {
  |- imp(not(imp(p1, not(p2))), and(p1, p2))
}
axiom or.def.1(prop p1, prop p2) {
  |- imp(or(p1, p2), imp(not(p1), p2))
}
axiom or.def.2(prop p1, prop p2) {
  |- imp(imp(not(p1), p2), or(p1, p2))
}
axiom iff.def.1(prop p1, prop p2) {
  |- imp(iff(p1, p2), and(imp(p1, p2), imp(p2, p1)))
}
axiom iff.def.2(prop p1, prop p2) {
  |- imp(and(imp(p1, p2), imp(p2, p1)), iff(p1, p2))
}
axiom true.def() {
  |- true
}
axiom false.def() {
  |- not(false)
}

type set
term set hs0
term prop forall(set s0, prop p1) { ∀(s0, p1) }
term prop exist(set s0, prop p1) { ∃(s0, p1) }
term prop eq(set s0, set s1) { (s0 = s1) }
axiom ax.gen(set s0, prop p1) {
  |- forall(s0, p1)
  -| p1
}
axiom ax.4(set s0, prop p1, prop p2) {
  |- imp(forall(s0, imp(p1, p2)), imp(forall(s0, p1), forall(s0, p2)))
}
axiom ax.5(set s0, prop p1) {
  |- imp(p1, forall(s0, p1))
  diff s0 p1
}
axiom exist.def(set s0, prop p1) { |- iff(exist(s0, p1), not(forall(s0, not(p1)))) }
axiom ax.6(set s0, set s1) { |- exist(s0, eq(s0, s1)) }
axiom ax.7(set s0, set s1, set s2) { |- imp(eq(s0, s1), imp(eq(s0, s2), eq(s1, s2)))}
axiom ax.10(set s0, prop p1) {
  |- imp(not(forall(s0, p1)), forall(s0, not(forall(s0, p1))))
}
axiom ax.11(set s0, set s1, prop p1) {
  |- imp(forall(s0, forall(s1, p1)), forall(s1, forall(s0, p1)))
}
axiom ax.12(set s0, set s1, prop p1) {
  |- imp(eq(s0, s1), imp(p1, forall(s0, imp(eq(s0, s1), p1))))
}

term prop neq(set s0, set s1) { (s0 ≠ s1) }

axiom neq.def(set s0, set s1) {
  |- iff(neq(s0, s1), not(eq(s0, s1)))
}
// [t / s] p0
// t : target
// s : source
term prop subs(set t, set s, prop p) { ([ t / s ] p) } 
axiom subs.def(set t, set s, prop p, set hs) {
  |- iff(subs(t, s, p), forall(hs, imp(eq(hs, t), forall(s, imp(eq(s, hs), p)))))
  diff hs t
  diff hs s
  diff hs p
}

// abstraction
term set abs(set s0, prop p1) { {s0 | p1} }
term prop in(set s0, set s1) { (s0 ∈ s1) }
axiom abs.def(set s0, set s1, prop p1) {
  |- iff(in(s0, abs(s1, p1)), subs(s0, s1, p1))
}
axiom zfc.ax.ext(set s0, set s1, set s2) {
  |- imp(forall(s0, iff(in(s0, s1), in(s0, s2))), eq(s1, s2))
  diff s0 s1 s2
}
axiom ax.8(set s0, set s1, set s2) {
  |- imp(eq(s0, s1), imp(in(s0, s2), in(s1, s2)))
}
axiom ax.9(set s0, set s1, set s2) {
  |- imp(eq(s0, s1), imp(in(s2, s0), in(s2, s1)))
}

term set singleton(set s0) { {s0} }
term set pair(set s0, set s1) { {s0, s1} }
term set opair(set s0, set s1) { (s0, s1) }

axiom singleton.def.1(set s0) {
  |- in(s0, singleton(s0))
}
axiom singleton.def.2(set s0, set s1) {
  |- iff(in(s0, singleton(s1)), eq(s0, s1))
}
axiom pair.def.1(set s0, set s1) {
  |- in(s0, pair(s0, s1))
}
axiom pair.def.2(set s0, set s1) {
  |- in(s1, pair(s0, s1))
}
axiom pair.def.3(set s0, set s1, set s2) {
  |- iff(in(s0, pair(s1, s2)), or(eq(s0, s1), eq(s0, s2)))
}
axiom opair.def(set s0, set s1) {
  |- eq(opair(s0, s1), pair(singleton(s0), pair(s0, s1)))
}