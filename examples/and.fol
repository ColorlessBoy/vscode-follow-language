/*
  # and 
*/

thm and.left(prop p0, prop p1) {
  |- imp(and(p0, p1), p0)
} = {
  syl(and(p0,p1), p0, not(imp(p0, not(p1))))
  and.def.1(p0, p1)
  contra.1i(imp(p0,not(p1)), p0)
  absurd.1(p0, not(p1))
}

thm and.right(prop p0, prop p1) {
  |- imp(and(p0, p1), p1)
} = {
  syl(and(p0,p1), p1, not(imp(p0, not(p1))))
  and.def.1(p0, p1)
  contra.1i(imp(p0,not(p1)), p1)
  ax.1(not(p1), p0)
}

thm and.forintro(prop p0, prop p1) {
  |- imp(p0, imp(p1, and(p0, p1)))
} = {
  syl6(p0, p1, and(p0,p1), not(imp(p0, not(p1))))
  and.def.2(p0, p1)
  syl(p0, imp(p1,not(imp(p0,not(p1)))), imp(imp(p0,not(p1)), not(p1)))
  contra.2(imp(p0,not(p1)), p1)
  com12(p0, imp(p0,not(p1)), not(p1))
  id(imp(p0,not(p1)))
}

thm and.intro(prop p0, prop p1) {
  |- and(p0, p1)
  -| p0
  -| p1
} = {
  ax.mp(and(p0,p1), p1)
  ax.mp(imp(p1,and(p0,p1)), p0)
  and.forintro(p0, p1)
}

// Importation inference.
thm and.impo(prop p0, prop p1, prop p2) {
  |- imp(and(p0, p1), p2)
  -| imp(p0, imp(p1, p2))
} = {
  syl(and(p0,p1), p2, not(imp(p0,not(p1))))
  and.def.1(p0, p1)
  contra.1i(imp(p0,not(p1)), p2)
  com12(not(p2), p0, not(p1))
  contra.3d(p0, p2, p1)
}

// Exportation inference
thm and.expo(prop p0, prop p1, prop p2) {
  |- imp(p0, imp(p1, p2))
  -| imp(and(p0, p1), p2)
} = {
  syl6(p0, p1, p2, and(p0, p1))
  and.forintro(p0, p1)
}

thm and.comm(prop p0, prop p1) {
  |- imp(and(p0, p1), and(p1, p0))
} = {
  and.impo(p0, p1, and(p1,p0))
  com12(p0, p1, and(p1,p0))
  and.forintro(p1, p0)
}

thm and.intro.d(prop p0, prop p1, prop p2) {
  |- imp(p0, and(p1, p2))
  -| imp(p0, p1)
  -| imp(p0, p2)
} = {
  mpd(p0, and(p1,p2), p2)
  syl(p0, imp(p2,and(p1,p2)), p1)
  and.forintro(p1, p2)
}